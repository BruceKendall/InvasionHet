---
title: More on distributions
author: Bruce Kendall
date: '2018-11-20'
slug: more-on-distributions
categories:
  - Code development
  - Parameter estimation
tags:
  - dispersal
---



<pre class="r"><code>temp &lt;- filter(disperseLer, ID == &quot;100_0&quot;)
cens_data &lt;- cens_dispersal_data(temp, 7)</code></pre>
<div id="generalized-gamma" class="section level2">
<h2>Generalized gamma</h2>
<p>I’ve made a specialized start function for gengamma:</p>
<pre class="r"><code>start_gengamma</code></pre>
<pre><code>function (x, truncated = FALSE) 
{
    if (dim(as.matrix(x))[2] != 2) {
        stop(&quot;Only interval-censored methods have been developed in start_gengamma&quot;)
    }
    dist_list &lt;- c(&quot;lnorm&quot;, &quot;weibull&quot;, &quot;gamma&quot;)
    n &lt;- length(dist_list)
    base_fits &lt;- data.frame(dist = dist_list, AIC = numeric(n), 
        p1 = numeric(n), p2 = numeric(n), stringsAsFactors = FALSE)
    base_starts &lt;- array(list(NULL), n)
    if (truncated) {
        stop(&quot;Truncated methods have not yet been developed in start_gengamma&quot;)
    }
    for (i in 1:n) {
        fit &lt;- fitdistcens(x, base_fits$dist[i], base_starts[[i]])
        base_fits$AIC[i] &lt;- fit$aic
        base_fits$p1[i] &lt;- coef(fit)[1]
        base_fits$p2[i] &lt;- coef(fit)[2]
    }
    best &lt;- base_fits[which.min(base_fits$AIC), ]
    start_pars &lt;- with(best, switch(dist, lnorm = list(mu = p1, 
        sigma = p2, Q = 2), weibull = list(mu = log(p1), sigma = 1/p2, 
        Q = 1), gamma = list(mu = log(p1/p2), sigma = sqrt(1/p1), 
        Q = sqrt(1/p1))))
    return(start_pars)
}</code></pre>
<p>This can called via <code>start_params()</code>:</p>
<pre class="r"><code>start_params</code></pre>
<pre><code>function (x, dist, ...) 
{
    x_orig &lt;- x
    if (dim(as.matrix(x))[2] == 2) {
        x &lt;- apply(x, 1, mean)
    }
    else if (dim(as.matrix(x))[2] &gt; 2) {
        stop(&quot;x must be a vector or two-column matrix&quot;)
    }
    start_pars &lt;- switch(dist, invgauss = list(mean = mean(x), 
        shape = mean(x)^3/var(x)), gengamma = start_gengamma(x_orig, 
        ...), NULL)
    if (is.null(start_pars)) {
        warning(&quot;No method exists for setting start values for &quot;, 
            dist)
    }
    return(start_pars)
}</code></pre>
<p>Note that the optional parameter <code>truncated</code> can be passed through via the dots. The truncated case needs to be written (the function in fitdistcens will be different).</p>
<p>Note that there are comments in the code that are not coming through here—somehow the rmarkdown rendering is “tidying” the code output!</p>
</div>
<div id="exponential-power" class="section level2">
<h2>Exponential power</h2>
<p>This is another name for the generalized normal (<a href="https://en.wikipedia.org/wiki/Generalized_normal_distribution" class="uri">https://en.wikipedia.org/wiki/Generalized_normal_distribution</a>) and has been implemented in package <strong>gnorm</strong> (<a href="https://cran.r-project.org/web/packages/gnorm/vignettes/gnormUse.html" class="uri">https://cran.r-project.org/web/packages/gnorm/vignettes/gnormUse.html</a>). It’s a three-parameter distribution with the normal, Laplace and uniform distributions as special cases. It’s defined on the whole real line, so I could either truncate it (allowing the mode to be either positive or negative) or make a “half-gnorm,” setting the location parameter (mu) at zero and reflecting the distribution.</p>
<p>Getting start values for the parameters is non-trivial (the Gamma function would need to be inverted!), but a decent starting place in either case would be <code>beta = 2</code>, which gives the normnal distribution; in that case the <code>sigma</code> of the normal distribution is equivalent to <code>sqrt(2) * alpha</code>.</p>
</div>
<div id="half-normal" class="section level2">
<h2>Half-normal</h2>
<p>So let’s look at half-distributions (which will also be needed for 2Dt). Here’s what I think it would look like:</p>
<pre class="r"><code>dhnorm &lt;- function(x, sigma = 1, log = FALSE) {
  (x &gt; 0) * 2 * dnorm(x, 0, sigma, log)
}
phnorm &lt;- function(q, sigma = 1, lower.tail = TRUE, log.p = FALSE) {
  phn &lt;- (q &gt; 0) * (1 - 2 * pnorm(q, 0, sigma, lower.tail = FALSE))
  if (!lower.tail) phn &lt;- (q &gt; 0) * (1 - phn)
  if (log.p) phn &lt;- log(phn)
  phn
}
xx &lt;- seq(-1, 6, 0.1)
plot(xx, dhnorm(xx), type = &quot;l&quot;)</code></pre>
<p><img src="/InvasionHet/post/2018-11-20-more-on-distributions_files/figure-html/hnorm-1.png" width="672" /></p>
<pre class="r"><code>plot(xx, phnorm(xx), type = &quot;l&quot;)</code></pre>
<p><img src="/InvasionHet/post/2018-11-20-more-on-distributions_files/figure-html/hnorm-2.png" width="672" /></p>
<p>I’ve put the above functions in <code>dists.R</code> and added the distribution to <code>start_params()</code></p>
</div>
